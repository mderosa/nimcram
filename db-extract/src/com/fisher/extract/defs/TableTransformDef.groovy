package com.fisher.extract.defs;

import groovy.text.SimpleTemplateEngine

/**
 * An import to a table in tracker3 is defined in this class
 * <p>
 * The 'to' field is the table that will be populated in the target database.
 * The 'sourceSql' parameter should specify the sql to run against the source database
 * The 'idGenerator' is the name of the sequence that will generate primary keys in the given table (SEQUENCE) 
 * or just the string 'default' (INCREMENT).  If this option is specified then at least one of the member 
 * field transform definitions should have the useGenerator field set to true 
 * The 'idGeneratorType' is currently one of the values ofSEQUENCE or INCREMENT defined above
 * <p>
 * The 'writer' field specifies whether a record from the source database table will be written
 * to target database via a regular sql statement or via a stored procedure.  The configuration
 * for a sql insert is [method: WriteMethod.SQL]. The configuration for a stored procedure insert
 * is [method: WriteMethod:PROC, statement: '{? = sp_insert_to_table(?,?)}, outputParams:[], outputParamsLocation: PRE']
 *  
 */
class TableTransformDef {
	def to
	def fieldTransformDefs
	def sourceSql
	def idGenerator
	def idGeneratorType
	def logModificationData = false
	def writer = [method: WriteMethod.SQL]
	
	def targetPrimaryKey() {
		assert idGenerator, "this method should only be called in cases where the field transform defs are configured to provide a pk"
		def pk
		fieldTransformDefs.each {
			if (it.useGenerator) {
				pk = it.to
			}
		}
		assert pk, "we should always find a valid pk"
		return pk
	}
	
	def assertInvariant() {
		assert to, "Configuration Error: TableTransformDef.to is a required parameter"
		assert fieldTransformDefs.size() > 0, "Configuration Error: field transforms are missing from this table transform"
		if (writer.method == WriteMethod.PROC) {
			assert writer.statement, "Configuration Error: the configuration for a stored procedure insert should specify as stored procedure name"
			assert writer.statement.startsWith("{") && writer.statement.endsWith("}"), "Invalid form for stored proc call: missing start or end brackets"
		} else if (writer.method != WriteMethod.SQL) {
			assert false, "Configuration Error: encountered an unknown WriteMethod"
		}
		assert sourceSql, "Configuration Error: TableTransformDef.sourceSql is requried"
		
		def autogenColCount = 0
		fieldTransformDefs.each {
			if (it.useGenerator) {
				autogenColCount++
			}
		}
		if (autogenColCount == 0) {
			if (writer.method == WriteMethod.SQL) {
				assert idGenerator == null, "Configuration Error: TableTransformDef.idGenerator should not be defined for transforms that dont require autogenerated fields"
			} else if (writer.method == WriteMethod.PROC) {
				assert false, "Configuration Error: Generally one will want to specify a primary key for the table that is being update with the useGenerator member variable. The reason for this is that after any update via a stored procedure the code will want to get the primary key for the newly generatecd record"
			}
		} else if (autogenColCount == 1) {
			assert idGenerator != null, "Configuration Error: TableTransformDef.idGenerator should be defined so that a key can be generated for the defined autogenerated field"
			assert idGenerator != "", "Configuration Error: TableTransformDef.idGenerator should be defined so that a key can be generated for the defined autogenerated field"
			assert idGeneratorType != null, "Configuration Error: TableTransformationDef.idGeneratorType should be defined when an idGenerator is defined"
		} else {
			assert false, "Configuration Error: only one autogenerated field can be defined per table transform"
		}
		
		if (idGenerator && idGeneratorType) {
			if (idGeneratorType == IdGeneratorType.SEQUENCE) {
				assert idGenerator.contains(to), "Warning: in most cases the sequence for a table in the tracker db is named after the table itself"
			}
		}
	}
}
